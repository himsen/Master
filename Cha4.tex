\chapter{Defining Subversion}
\chaplab{definingSubversion}

Inspired from previous work \cite{DBLP:conf/crypto/YoungY96,DBLP:secSym}, we will in this chapter define what it means to subvert a cryptographic game. Namely, a successful subversion can leak information to the subverter, and only the subverter, and the output of a subverted device  is indistinguishable from the output of the original non-subverted device for everyone except the subverter. In addition to defining subversion of cryptographic games, we also provide results on general properties of our new framework.

We are interested in investigating \emph{subversions} of a device $\dev$. A subversion replaces the executable code of $\dev$ with a modified version $\bbdev$ authored by \emph{big brother} $\bb$. How $\bb$ manages to replace the code is out of scope. We just assume that it is somehow possible\footnote{Considering the negligent Internet behaviour by many people, this should be an easy task!}. Big brother aims to construct a subversion $\bbdev$ in such a way that it leaks information. Achieving leakage from a subverted device is basically trivial: $\bb$ simply modify $\dev$ to publicly output whatever $\bb$ wants leaked. It is clear that such subversion is easy to do for $\bb$ but it also allows anyone else to snatch the leaked information. Such subversions are useless from the perspective of big brother. To exclude them, we impose further restrictions on $\bbdev$: $\bb$ should be the only one knowledgeable about the replacement of $\dev$ with $\bbdev$. That is, no one should be able to \emph{detect} that the device $\dev$ have been subverted, except $\bb$. If $\bb$ construct a subversion with this property, we call the subversion \emph{undetectable}. Formally, undetectability will be formalised by an undetectability game, see \secref{nonInteractiveSubversion}. We call an entity trying to detect the presence of a subversion for a \emph{distinguisher}. The strength of a distinguisher varies depending on what output from the device $\dev$ is being made available to it. Two different strengths will be defined: weak and strong undetectability. For weak undetectability the distinguisher will only see the public output from $\dev$ while for strong undetectability the distinguisher will have access to (as the reader probably have guessed) both the secret and public output. In addition to undetectability, we also require that $\bbdev$ satisfy the same notion of security as $\dev$. Because the use of $\bbdev$ is assumed to be the same as $\dev$, it makes most sense to restrict attention to subversions that maintain the same level of security. In fact, we will see later that preservability of security is implied automatically (see \propref{strongImplyWeak} and \propref{interactivestrongImplyWeak}). Finally, we must also (obviously) require that $\bb$ is able to obtain some secret knowledge when $\dev$ is replaced by $\bbdev$. This latter restriction is elaborated in \secref{bigBrother} where we further discuss the role and characteristics of $\bb$. Essentially, we say that big brother $\bb$ is successful if the corresponding subversion $\bbdev$ can not be detected, preserves security and $\bb$ is able to recover secret information. 

This chapter is organised as follows: in \secref{bigBrother}, we discuss big brother. Subversion of non-interactive cryptographic games and interactive cryptographic games is defined in \secref{nonInteractiveSubversion} and \secref{interactiveSubversion}, respectively, and the scope of the definitions is also discussed. After each definition, we present some general properties of the framework.   

\section{Big Brother}
\seclab{bigBrother}

Big brother, denoted by $\bb$ is the manufacture of the subversion. It is the goal of $\bb$ to replace the code for $\dev$ by $\bbdev$ in such a way that when the user runs $\bbdev$ it leaks information to $\bb$. Instead of a priori defining that $\bb$ should obtain (e.g.) the secret key used in $\dev$, we use the security notion attached to $\dev$. This is a new approach, in the sense that previous work has used ah hoc quantifications of the recovery abilities of big brother and generally lacks rigour when defining the recovery capabilities. 

To simulate leak of information, we take a very liberal approach in which we say that $\bb$ needs only break the security of $\dev$ to `extract information'. The reasoning behind this is that it is the least restrictive and most general approach. Since the concept of a cryptographic device is very general, it likewise does not make sense to fix on some certain information, for example $\bbdev$ should leak the secret key, if such a key is not being generated by $\dev$ in the first place! Instead we include a very broad range of possible subversions by defining that recovery of secret information is possible if only $\bb$ can break the original security of $\dev$. For every $\bb$, we therefore associate a recovery algorithm $\bbrec$. The goal for $\bbrec$ is to break the security of $\bbdev$. We formalise this by testing whether the recovery algorithm breaks the (slightly modified) security game for $\cgame$. 

Of course $\bb$ should have some advantage over normal adversaries. This advantage is knowledge of the big brother secret key $\bbsk$, which is an input to the recovery algorithm. To take advantage of the secret key $\bbsk$, the corresponding public key $\bbpk$ is given as input to $\bbdev$. In practice, this amounts to a situation where $\bbpk$ has been embedded in the code for $\bbdev$. The big brother public key $\bbpk$ is therefore located on the subverted device. We make the assumption that this does not allow any distinguisher to discover that the device has been compromised. Since $\bbpk$ is a public key and there is a chance of finding it in the code, we let the key be public i.e. any distinguisher trying to distinguish $\dev$ and $\bbdev$ has access to $\bbpk$. 

Allowing a distinguisher access to the big brother public key is a different approach compared to recent works \cite{DBLP:secSym,cryptoeprint:2015:517,DBLP:conf/eurocrypt/DodisGGJR15,cryptoeprint:2015:683} where knowledge of the big brother symmetric key completely compromise big brother. In our model, knowledge of the big brother public key gives no extra advantage to a distinguisher even if all owners of a device, that has been subverted with the same big brother public key, cooperate.  In particular, successful reverse engineering of one device does not lead to detection of other subverted devices. 

Since the subverted device $\bbdev$ is supposed to replace device $\dev$ \emph{as is}, we will implicitly assume that $\bbdev$ behaves functionally equivalent\footnote{For example if $\dev$ is modelling an encryption with perfect correctness, then $\bbdev$ should also satisfy perfect correctness} to $\dev$. That is, whenever $\dev$ is usable, $\bbdev$ must also be usable and able to function in the same way without needing any modifications. It would be a trivial task to distinguish two devices that are not functionally equivalent. We will make sure to state precisely how each device should be used and what input/output is allowed. Concretely, the functionality requirements will be clear from the description of the cryptographic device. 

Recall from the previous paragraph that we require $\bbdev$ to be undetectable. $\bbdev$ being functionally equivalent to $\dev$ is the most basic form of undetectability. However we expect that big brother will aim to evade more sophisticated forms of detection. We formalise detection security as requiring that output from the subverted device and the original (non-subverted) device is indistinguishable also after (possible) multiple invocations. As discussed above, $\dev$ and $\bbdev$ should be indistinguishable even to a test that has knowledge of the big brother public key.

Since a device $\dev$ has two outputs, one public and one private output, we can consider two different distinguishers. The direct user $\user$ of a device will be the most powerful distinguisher. $\user$ have knowledge of both the public and private output. A distinguisher that is only observing a device can at most learn the public output. We call such a distingusher an eavesdropper, which will be denoted by $\eve$. Even though $\bb$ essentially is an adversary, when formulating undetectability we actually consider $\user$ and $\eve$ as adversaries who are trying to distinguish two constructions through a `security game'. This is a funny example of when one wants to describe a property in cryptography the threat models sometimes needs to be turned upside-down. 

As mentioned in previous paragraphs, $\bb$ will embed a public key $\bbpk$ into $\bbdev$, which can be used to construct the subversion. This public key together with the corresponding private key must therefore be generated by $\bb$ before constructing $\bbdev$. More importantly the generating of the big brother keys happens \emph{before} any user uses $\bbdev$. We therefore give big brother access to parameters belonging to the device. In a real-world scenario, big brother would also have access do these parameters. Hence this choice allows for a more realistic model.

We now formally define big brother. In summary, we want big brother to learn some information that a priori should remain secret. To achieve this, big brother is constructing a similar device $\bbdev$ that is functionally equivalent to $\dev$ but contains a secret backdoor that only big brother can use. The backdoor is constructed by allowing big brother to embed a big brother public key $\bbpk$ inside $\bbdev$. Big brother can use the backdoor and extract information by using the corresponding big brother secret key $\bbsk$. 

In the sequel, we will often refer to a big brother without mentioning a non-interactive/interactive suffix. It will be clear from the context what kind of big brother that is referred to.

\subsection{Non-interactive big brother}

We first present the definition of a big brother for the non-interactive case. 

\begin{defn}
\deflab{nonInteractiveBigBorther}
	A \textbf{Non-interactive big brother} for a non-interactive cryptographic game $\listcgame$ is a 3-tuple $(\bbgen,\bbdev, \bbrec)$ of $\PPT$ algorithms denoted by $\bb$, where
	\begin{itemize}
	\itemsep-0.1em
		\item $\bbgen$ is a $\PPT$ algorithm that we call the \emph{big brother key generation} algorithm, which on input the security parameter $n$  and parameter $\params$ outputs a big brother public key $\bbpk\in\{0,1\}^*$ and a big brother secret key $\bbsk\in\{0,1\}^*$ both with length at least $n$. We write $(pk,sk)\leftarrow \bbgen(1^n, \params)$. 
		\item $\bbdev$ is a $\PPT$ algorithm that we call the \textit{subversion of $\dev$}, which takes as input the security parameter $n$, parameters $\params$ and big brother public key $\bbpk$ and outputs two transcripts, public and secret, in the same range as the corresponding transcripts from $\dev$. We write $(\ptrans,\strans)\leftarrow \bbdev(1^n,\params,\bbpk)$. 
		\item $\bbrec$ is a $\PPT$ algorithm that we call the \textit{big brother recovery algorithm}, which on input a big brother secret key $\bbsk$ and public transcript $\ptrans$ outputs information $\delta\in\{0,1\}^*$. We write $\delta\leftarrow \bbrec(\bbsk,\ptrans)$. 
	\end{itemize} 
\end{defn}

Notice that the recovery algorithm $\bbrec$ effectively works as an adversary for the security game of $\cgame$ with the extra knowledge of the big brother secret key $\bbsk$. 

\subsection{Interactive big brother}
\seclab{interactiveBigBrother}

The interactive big brother is different from the non-interactive counterpart in the sense that we are subverting a device that interacts with another party. The subverted device $\bbdev$ and the big brother recovery algorithm $\bbrec$ therefore needs to be changed accordingly. 

\begin{defn}
\deflab{interactiveBigBrother}
	An \textbf{interactive big brother} for an interactive cryptographic game $\listcgame$ is a 3-tuple $(\bbgen,\bbdev, \bbrec)$ denoted by $\bb$, where
	\begin{itemize}
	\itemsep-0.1em
		\item $\bbgen$ is a $\PPT$ algorithm that we call the \emph{big brother key generation} algorithm, which on input the security parameter $n$  and parameter $\params$ outputs a big brother public key $\bbpk\in\{0,1\}^*$ and a big brother secret key $\bbsk\in\{0,1\}^*$ both with length at least $n$. We write $(pk,sk)\leftarrow \bbgen(1^n, \params)$. 
		\item $\bbdev$ is a $\PPT$ party that we call the subversion of $\dev$. $\bbdev$ functions the same way as $\dev$ in its interaction with another party (i.e it must adhere to the same message schedules as $\dev$ and return a public and secret transcript) but in addition to the input given to $\dev$ it is also given the big brother public key $\bbpk\in\{0,1\}^*$ as input. 
		\item $\bbrec$ is a $\PPT$ party that we call the \textit{big brother recovery algorithm}. $\bbrec$ functions like a $\PPT$ party $\party$ but in addition to be given $\params$ as input, it also receives the big brother secret key $\bbsk$ as input to its return algorithm $\return_{\bbrec}$. The return function of $\bbrec$ outputs information $\delta\in\{0,1\}^*$. We write $\delta\leftarrow\return_{\bbrec}(\st_{\bbrec},\bbsk)$.
	\end{itemize} 
\end{defn}

The main difference between \defref{nonInteractiveBigBorther} and \defref{interactiveBigBrother} is that in the latter, $\bbdev$ and $\bbrec$ are two parties that can interact with another party. In fact, $\bbrec$ is interacting with $\bbdev$ in its attempt to abuse its knowledge of $\bbsk$. This implies that $\bbrec$ is a rather powerful recovery algorithm. For example in \chapref{publicKeyEncryptionSubversion}, we present a subversion of the $\elGamal$ scheme in the $\CPA$ security game. When $\bbrec$ tries to recover information from $\bbdev$, it can do so in an adaptive manner i.e. choose which messages to be send to $\bbdev$ and act accordingly. In the case of the particular subversion of $\elGamal$ this makes no difference ($\bbrec$ can choose any messages and still be able to recover information) but in other constructions it might make a difference that $\bbrec$ is able to decide its own messages. We quantify how good $\bbrec$ must be in the subsequent section. 

\section{Subversion}
\seclab{subversion}

Consider a device $\dev$ and its subverted counterpart $\bbdev$. Both devices output transcripts (in the case of an interactive subversion the transcripts are a concatenation of several messages): a public transcript $\ptrans$ and a private transcript $\strans$. As mentioned in the previous sections, these transcripts will, respectively, contain whatever output is considered public, thereby visible to an eavesdropper $\eve$, and what output is regarded as private for everyone except a user $\user$. Subversions that are undetectable when considering eavesdroppers are weak while subversions that are also successful when considering users are strong. A distinguisher trying to distinguish $\dev$ and $\bbdev$ gets either $\ptrans$ or both transcripts depending on the type of distinguisher and must then guess from which device the transcript(s) is(are) generated.  

The only possible mean (at least in our model) for users and eavesdroppers to detect a subversion is to consider the output of the device they are using, or observing in the case of an eavesdropper. We aim for subversions that avoids detection in a powerful way. This means we will require that $\bb$ is able to fend off very refined tests. In \secref{nonInteractiveSubversion} and \secref{interactiveSubversion}, we define what it means to do so in respectively the non-interactive and  the interactive case. But first we discuss the scope of our definitions.

\subsection{Scope}
\seclab{scope}

There are some restrictions on the scope of the framework (included on purpose that is). In our definition of a subversion, we do not consider attempts that include side-channel analysis or other \emph{physical} means of distinguishing devices. It may well be possible to construct a subliminal channel by using careful timing of a device $\dev$. E.g. if $\dev$ represent an encryption algorithm then big brother could stutter the encryption of a message depending on a bit of the secret key at a specific position and thereby leaking information in the bit\footnote{This simplistic way of using side-channel does actually not represent a successful subversion in our model because a distinguisher could do the same side-channel analysis. Hence in deploying a side-channel subversion, big brother needs to be a bit more clever e.g. try to obfuscate the side-channel depending on the big brother public/secret key}. 

As mentioned in \secref{bigBrother}, we do not consider how big brother is going to replace the code. We therefore assume that by some magic divine power, big brother has a way of replacing $\dev$ with $\bbdev$. This also implies that we make absolutely no conclusions on the practical exploitability level of our work - such work has been carried out in e.g. \cite{Bernstein2014}. 

Finally, if a subversion fails to adhere to our definition it does not necessarily mean it can be detected. When a subversion fails to satisfy our undetectable condition, it implies that a distinguisher has non-negligible probability of distinguishing between a subverted device and the non-subverted device. What this means in a theoretical context is clear (non-negligible advantage) but it does not necessarily change the distinguishers ability to actually detect a subversion in practice (as such, a subversion satisfying our undetectability condition is very strong): the fact that a probability is non-negligible does not mean it is big, it simply means it does not decrease (insanely) fast. Specifically, a detection probability of $\frac{1}{2^{256}}$ would be non-negligible but totally useless in practice.

\subsection{Non-interactive subversion}
\seclab{nonInteractiveSubversion}

Subversion of a non-interactive cryptographic game is the easiest to define. Details are as follows.

\begin{defn}
\deflab{nicgSubversion}
	Given a secure non-interactive cryptographic game $\listcgame$. A big brother $\listbb$ for $\cgame$ is a weak/strong $(t,K)$-subversion of $\cgame$ if 
	\begin{enumerate}[1.]

		\item Big brother can recover information: define recovery advantage as
		\begin{align*} 
			\adv_{\bb}^{\recgame}(\bbrec)\defeq \secf(n)\cdot \left\vert \prob{\true\leftarrow \recgame_{\bb}^{\bbrec}(n)} - \basep(n)\right\vert,
		\end{align*}
		where the probability is over randomness used in the game $\recgame_{\bb}^{\adve}(n)$, which is defined in \figref{RecSecGame}. $\bb$ recovers information if  there exists $N\in\N$ such that
		\begin{align*}
			\adv_{\bb}^{\recgame}(\bbrec)>K
		\end{align*}
		for all $n>N$ and $\bbrec$ is a $\PPT$ algorithm.
		\item  Detection is impossible: for a $\PPT$ distinguisher $\dist$, we define 
		\begin{align*}
		\adv_{\dev,\bbdev}^{\notationtypedetect}(\dist) \defeq 2\left\vert \prob{\true\leftarrow \typedetect{\dev}{\bbdev}{\dist}}-\frac{1}{2}\right\vert 
		\end{align*}
		for $\type\in\{\weakly,\strongly\}$ and probability is over randomness used in the game $\typedetect{\dev}{\bbdev}{\adve}$ defined in \figref{detectgame}. A $\PPT$ distinguisher $\dist$ can not detect the subversion $\bb$ if there exists a negligible function $\negl$ such that
		\begin{align*}
			\adv_{\dev,\bbdev}^{\notationtypedetect}(\dist)\leq \negl(n),
		\end{align*}
		where $\dist$ is allowed to make $t$ queries to the oracle $\oracle$.
		\begin{boxfigTwo}{Distinguish game for weak/strong subversion.}{detectgame}
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
 	\item[\underline{\textbf{Game} $\weakdetect{\dev}{\bbdev}{\eve}$}] ~
 	
 		$\params\leftarrow\param(1^n)$ \\
 		$b\drawbit$ \\
 		$(\bbpk,\bbsk)\leftarrow \bbgen(1^n,\params)$  \\
 		$\hat{b}\leftarrow \eve^{\oracle}(\bbpk,\params)$ \\
 		\Ret $\askequal{\hat{b}}{b}$

	\item[\underline{$\oracle$}] ~
	
		If $b=0$: $(\ptrans,\strans)\leftarrow \dev(1^n,\params)$\\
		If $b=1$: $(\ptrans,\strans)\leftarrow \bbdev(1^n,\params,\bbpk)$ \\
		\Ret $\ptrans$
		\smallskip
  	\end{description}
\end{minipage}
    & 
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
 	\item[\underline{\textbf{Game} $\strongdetect{\dev}{\bbdev}{\user}$}] ~
 	
 		$\params\leftarrow\param(1^n)$ \\
 		$b\drawbit$ \\
 		$(\bbpk,\bbsk)\leftarrow \bbgen(1^n,\params)$  \\
 		$\hat{b}\leftarrow \user^{\oracle}(\bbpk,\params)$ \\
 		\Ret $\askequal{\hat{b}}{b}$

	\item[\underline{$\oracle$}] ~
	
		If $b=0$: $(\ptrans,\strans)\leftarrow \dev(1^n,\params)$\\
		If $b=1$: $(\ptrans,\strans)\leftarrow \bbdev(1^n,\params,\bbpk)$ \\
		\Ret $(\ptrans,\strans)$
		\smallskip
  	\end{description}
\end{minipage}
     \\ \hline 
	 $\eve$ is allowed to make $t$ queries to the oracle $\oracle$. &
	 $\user$ is allowed to make $t$ queries to the oracle $\oracle$  \\
\end{boxfigTwo}
		\item Preserve security: for every $\PPT$ adversary $\adve$ there exists a negligible function $\negl$ such that
		\begin{align*}
			\adv_{\bb}^{\secgame}(\adve) \leq \negl(n).
		\end{align*}   
		The left-hand side is defined as
		\begin{align*}
			\adv_{\bb}^{\secgame}(\adve) \defeq \secf(n)\cdot\left\vert \prob{\true\leftarrow\secgame_{\bb}^{\adve}(n)} - \basep(n)\right\vert,
		\end{align*}
		where the probability is taken over the randomness in Game $\secgame_{\bb}^{\adve}(n)$ defined in \figref{RecSecGame}.
		\begin{boxfigTwo}{Recovery (left) and preservability (right) game for big brother $\bb$}{RecSecGame}
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
	\item[\underline{\textbf{Game} $\recgame_{\bb}^{\adve}(n)$}] ~
 	
 		$\params \leftarrow \param(1^n)$ \\
 		$(\bbpk,\bbsk)\leftarrow \bbgen(1^n,\params)$ \\
 		$(\ptrans,\strans)\leftarrow \bbdev(1^n,\params,\bbpk)$ \\
 		$\delta \leftarrow \adve(\bbsk,\params,\ptrans)$ \\
 		$\bool \leftarrow \pred(\ptrans,\strans,\delta)$ \\
		\Ret $\bool$
		\smallskip
  	\end{description}
\end{minipage}
    & 
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
	\item[\underline{\textbf{Game} $\secgame_{\bb}^{\adve}(n)$}] ~
 	
 		$\params \leftarrow \param(1^n)$ \\
 		$(\bbpk,\bbsk)\leftarrow \bbgen(1^n,\params)$ \\
 		$(\ptrans,\strans)\leftarrow \bbdev(1^n,\params,\bbpk)$ \\
 		$\delta \leftarrow \adve(\bbpk,\params,\ptrans)$ \\
 		$\bool \leftarrow \pred(\ptrans,\strans,\delta)$ \\
		\Ret $\bool$
		\smallskip
  	\end{description}
\end{minipage}
\\
\end{boxfigTwo}
	\end{enumerate}
$t$ is a polynomial in $n$ and $K\in(0,1]$. If (1) is true for arbitrary $t>0$ we call $\bb$ a weak/strong $K$-subversion of $\cgame$ and we call $\bb$ a weak/strong subversion of $\cgame$ if there exist some constant $K$ such that $\bb$ is a weak/strong $K$-subversion. If properties 1, 2 and 3 are satisfied we call $\bb$ \emph{recoverable}, \emph{undetectable} and \emph{security preserving}. Property 1, 2 and 3 above are referred to as \emph{recoverability}, \emph{undetectability} and \emph{preservability}, respectively.
\end{defn}

We give some comments on each game below:

\noindent\textbf{Recovery game:} The recovery game first generates parameters and then generates the big brother keys. $\bbdev$ is then run with input the big brother public key and parameters, and the output is given to $\adve$. Apart from being given the public transcript, $\adve$ is also given the big brother secret key and parameters, and then outputs some information $\delta$ that is fed into the predicate function. 

\noindent\textbf{Detection game:} To begin with $\eve$ and $\user$ are given the big brother public key $\bbpk$. They can then query the oracle $\oracle$ at most $t$ times. The output comes either from $\dev$ or $\bbdev$ depending on the bit $b$ drawn in the game. In the weak undetectability game the answer from the oracle $\oracle$ is the public transcript $\ptrans$ while in the strong undetectability game the answer from the oracle $\oracle$ is both transcripts $\ptrans$ and $\strans$.  

\noindent\textbf{Security game:} The only difference between the two games $\recgame_{\bb}^{\adve}(n)$ and $\secgame_{\bb}^{\adve}(n)$ is that in the former the adversary $\adve$ is given the big brother secret key while in the latter this is not the case. That is, the games completely describe that obtaining the big brother secret key is enough to take advantage of the subversion. However, not knowing the secret key leaves an attacker with no chances of taking advantage of the subversion.\\ 

We emphasise that \defref{nicgSubversion} captures the user's or eavesdropper's inability to know which device is being used. Even if the detection advantage is rather large it is not immediately clear that detection is possible. A distingusher would simple not know what to look for. When detection advantage is small, big brother has essentially forced distingushers to rely on `physical' means e.g. reverse-engineering or timing-analysis. 

Since we are not much interested in the practical performance of big brother, we say that any big brother who satisfy the above definition with respected to a non-interactive game $\cgame$ implies that $\cgame$ is susceptible to a subversion attack.

Below we prove a consistency result: a non-interactive cryptographic game that is strongly subvertable is also weakly subvertable.  

\begin{prop}
\proplab{strongImplyWeak}
Let $\listcgame$ be a non-interactive cryptographic game and assume $\listbb$ is a strong $(t,K)$-subversion of $\cgame$. Then $\bb$ is also a weak $(t,K)$-subversion of $\cgame$. 
\end{prop}

\begin{proof}
Since we have not changed either $\dev$ or $\bb$, properties (1) and (3) in \defref{nicgSubversion} are still satisfied. We therefore only have to prove that property (2) is satisfied in the weak case.  

Assume $\eve$ is a $\PPT$ eavesdropper and consider the game $\weakdetect{\dev}{\bbdev}{\eve}$. We then define a $\PPT$ user $\user$ such that 
\begin{align*}
	\adv_{\dev,\bbdev}^{\weakdetectplain}(\eve) = \adv_{\dev,\bbdev}^{\strongdetectplain}(\user),
\end{align*}
where $\adv_{\dev,\bbdev}^{\strongdetectplain}(\user)$ is the advantage of $\user$ in the game $\strongdetect{\dev}{\bbdev}{\user}$. We define $\user$ below: in the description $\oracle$ denotes the oracle from the game $\strongdetect{\dev}{\bbdev}{\user}$.

%\vspace*{-.3cm}
\begin{Algorithm}[]{7cm}
\captionUser
\caption{$\user$}
\label{alg:weakStrong}
\begin{algorithmic}[1]
\Require $(\bbpk,\params)$ 
\State Initialise list $L_{\ptrans}$
\State Make $t$ queries to $\oracle$
\State Let $L_{\ptrans}$ contain the public transcript answers from the queries to $\oracle$
\State $\hat{b}\leftarrow\eve^{\oracle_{\user}}(\bbpk,\params)$
\State \Ret $\hat{b}$
\Statex\hrulefill
\end{algorithmic}
\begin{algorithmic}[1]
\Statex \underline{Device oracle: \textbf{$\oracle_{\user}$} $i$'th query}
\Statex
\State \Ret $L_{\ptrans}[i]$
\end{algorithmic}
\end{Algorithm}
Because $\eve$ runs in polynomial-time, $\user$ also runs in polynomial-time. It is clear that $\user$ wins exactly when $\eve$ guesses the correct bit. The probability of $\eve$ guessing correctly when used as a subroutine by $\user$ is $\prob{\true\leftarrow\weakdetect{\dev}{\bbdev}{\eve}}$: this follows because the oracle answers to $\eve$ when used as a subroutine by $\user$ are the same oracle answers $\eve$ receives in the game $\weakdetect{\dev}{\bbdev}{\eve}$ (they are therefore also distributed identically). The parameters $\params$ and big brother public key $\bbpk$ are also the same in both situations. Because $\bb$ is a strong $(t,K)$-subversion of $\cgame$ there exists a negligible function $\negl$ such that 
\begin{align*}
	\adv_{\dev,\bbdev}^{\weakdetectplain}(\eve) &= \secf(n)\left\vert \prob{\true\leftarrow \weakdetect{\dev}{\bbdev}{\eve}}-\basep(n)\right\vert \\
	& = \secf(n)\left\vert \prob{\true\leftarrow \strongdetect{\dev}{\bbdev}{\user}}-\basep(n)\right\vert \\
	& = \adv_{\dev,\bbdev}^{\strongdetectplain}(\user) \leq \negl(n),
\end{align*}
which proves what we want.
\end{proof}

We can actually reduce the number of properties required to prove that a big brother is a successful subversion. Namely, given a secure non-interactive cryptographic game $\cgame$ and a big brother $\bb$ that satisfies strong undetectability, it is possible to prove that $\bb$ also satisfy preservability i.e. it conforms to the same notion of security as $\cgame$ does. 

\begin{prop}
\proplab{preservabilityRedundant}
Let $\listcgame$ be a non-interactive cryptographic game and $\listbb$ a big brother for $\cgame$. If $\cgame$ is secure and $\bb$ is strongly undetectable, then $\bb$ also preserves security i.e. for all $\PPT$ adversaries $\adve$ there exists a negligible function $\negl$ such that
\begin{align*}
	\adv_{\bb}^{\secgame}(\adve) \leq \negl(n).
\end{align*}
\end{prop}

\begin{proof}
	We start by constructing a reduction from preservability of $\bb$ to undetectability of $\bb$. Let $\adve$ be a $\PPT$ adversary and consider the game $\secgame_{\bb}^{\adve}(n)$. We construct a $\PPT$ user $\user$, using $\adve$ as a subroutine, that tries to distinguish between $\dev$ and $\bbdev$. In constructing $\user$ we use the predicate function $\pred$, which is possible because in the strong undetectability game $\strongdetect{\dev}{\bbdev}{\user}$, $\user$ is given the secret transcript $\strans$. A detailed description of $\user$ is given below: in the description we use $\oracle$ to refer to the device oracle in the game $\strongdetect{\dev}{\bbdev}{\user}$.
	
%\vspace*{-.3cm}
\begin{Algorithm}[]{6cm}
\captionUser
\caption{$\user$}
\label{alg:ImplySecurity1}
\begin{algorithmic}[1]
\Require $(\params,\bbpk)$
\State Query: $(\ptrans,\strans)\leftarrow\oracle$
\State $\delta\leftarrow \adve(\bbpk,\params,\ptrans)$
\State $\bool \leftarrow \pred(\ptrans,\strans,\delta)$
\If{$\bool = \true$}
\State \Ret $1$
\Else
\State \Ret $0$
\EndIf
\end{algorithmic}
\end{Algorithm} 

Because $\adve$ and $\pred$ are polynomial-time algorithms, $\user$ is also a polynomial-time algorithm. Note that we only need one query from $\oracle$. Hence it does not matter how many queries $\user$ is allowed to make (a distinguisher is always allowed to make at least one).  Conditioning on the value of $b$ we obtain
\begin{align}
	\adv_{\dev,\bbdev}^{\strongdetectplain}(\user) & = 2\cdot \left\vert \prob{\true\leftarrow \strongdetect{\dev}{\bbdev}{\user}} - \frac{1}{2} \right\vert  \nonumber \\
	&  = 2\cdot \bigg\vert \frac{1}{2}\prob{\true\leftarrow \strongdetect{\dev}{\bbdev}{\user}\,\big\vert\,b = 1} +  \nonumber \\
	&\qquad\qquad\qquad \frac{1}{2}\prob{\true\leftarrow \strongdetect{\dev}{\bbdev}{\user}\,\big\vert\,b = 0} - \frac{1}{2} \bigg\vert\nonumber \\
	& = 2\cdot \left\vert \frac{1}{2}\left( \condprob{\bool = \true}{b = 1} + \condprob{\bool = \false}{b = 0}\right) - \frac{1}{2} \right\vert  \nonumber \\
\label{eq:cha3_0} 	& = \left\vert \condprob{\bool = \true}{b = 1} + \condprob{\bool = \false}{b = 0} -1 \right\vert.
\end{align}
Let us now consider the two conditional probabilities separately. The first conditions on $b = 1$ which implies that the transcript returned by $\oracle$ is generated by $\bbdev$ with input $\params$ and $\bbpk$. That is, the input to $\adve$ has the same distribution as in the game $\secgame_{\bb}^{\adve}(n)$. Therefore, the event that $\bool = \true$, has the same probability as $\adve$ outputting a valid $\delta$ i.e.
\begin{align}
\label{eq:cha3_1}
	\condprob{\bool = \true}{b = 1} = \prob{\true \leftarrow \secgame_{\bb}^{\adve}(n)}.
\end{align}
The second probability conditions on $b = 0$, which means that the answer from $\oracle$ is computed by running $\dev$ on input $\params$. The distribution of the input to $\adve$ is therefore identical to the distribution of the input given to $\adve$ in the modified game $\pneg{\secgame}_{\cgame}^{\adve}(n)$ defined in \figref{secGameMod}. Note that this is a modification of the security game for $\cgame$, where $\bbpk$ is given as additional input to the adversary $\adve$. 

\begin{boxfigGame}{Modified security game for a non-interactive cryptographic game $\cgame$.}{secGameMod}
  \begin{description}
	\item[\underline{\textbf{Game} $\pneg{\secgame}_{\cgame}^{\adve}(n)$}] ~
 	
 		$\params \leftarrow \param(1^n)$ \\
 		$(\bbpk,\bbsk)\leftarrow \bbgen(1^n,\params)$ \\
 		$(\ptrans,\strans)\leftarrow \dev(1^n,\params)$ \\
 		$\delta \leftarrow \adve(\bbpk,\params,\ptrans)$ \\
 		$\bool \leftarrow \pred(\ptrans,\strans,\delta)$ \\
		\Ret $\bool$	
  \end{description}
\end{boxfigGame}

Thus we have the following identity
\begin{align*}
	\condprob{\bool = \false}{b = 0} = \prob{\false \leftarrow \pneg{\secgame}_{\cgame}^{\adve}(n)}.
\end{align*}
But obviously since $\params$ and $\ptrans$ is completely independent of $\bbpk$ (and $\bbsk$) $\adve$ learns no extra information compared to the original game. We can easily define a new $\PPT$ adversary $\adve'$ for the game $\secgame_{\cgame}^{\adve'}(n)$ that uses $\adve$ as a subroutine to attack the security of $\cgame$ (we can generate identically distributed input since $\ptrans$ is independent of $\bbpk$), such that the following will be the case
\begin{align}
\label{eq:cha3_2}
	\prob{\false\leftarrow \secgame_{\cgame}^{\adve'}(n)} = \prob{\false \leftarrow \pneg{\secgame}_{\cgame}^{\adve}(n)}.
\end{align}
Using identities \ref{eq:cha3_0}, \ref{eq:cha3_1} and \ref{eq:cha3_2} we obtain
\begin{align*}
	\adv_{\dev,\bbdev}^{\strongdetectplain}(\user) & = \left\vert \prob{\true\leftarrow \secgame_{\bb}^{\adve}(n)} + \prob{\false \leftarrow \secgame_{\cgame}^{\adve'}(n)} - 1\right\vert \\
	& = \left\vert \prob{\true\leftarrow \secgame_{\bb}^{\adve}(n)} + \left( 1 - \prob{\true \leftarrow \secgame_{\cgame}^{\adve'}(n)}\right) - 1\right\vert \\
	& = \left\vert \prob{\true\leftarrow \secgame_{\bb}^{\adve}(n)} - \prob{\true \leftarrow \secgame_{\cgame}^{\adve'}(n)}\right\vert \\
	& = \left\vert \left(\prob{ \true\leftarrow \secgame_{\bb}^{\adve}(n)} - \basep(n)\right)  - \left( \prob{\true \leftarrow \secgame_{\cgame}^{\adve'}(n)} - \basep(n) \right)\right\vert \\ 
	& \geq \left\vert \prob{ \true\leftarrow \secgame_{\bb}^{\adve}(n)} - \basep(n)\right\vert  - \left\vert \prob{\true \leftarrow \secgame_{\cgame}^{\adve'}(n)} - \basep(n) \right\vert.
\end{align*}
By multiplying $\secf(n)$ ($>0$) on both sides and rearrange things a bit we get
\begin{align*}
\secf(n)\cdot\adv_{\dev,\bbdev}^{\strongdetectplain}(\user) + \adv_{\cgame}^{\secgame}(\adve') &= \secf(n)\cdot \adv_{\dev,\bbdev}^{\strongdetectplain}(\user) + \\ 
&\qquad\qquad\secf(n)\cdot\left\vert \prob{\true \leftarrow \secgame_{\cgame}^{\adve'}(n)} - \basep(n) \right\vert \\ 
& \geq \secf(n)\cdot \left\vert \prob{ \true\leftarrow \secgame_{\bb}^{\adve}(n)} - \basep(n)\right\vert \\
& \geq \adv_{\bb}^{\secgame}(\adve).
\end{align*}
Since $\secf(n)$ is a polynomial, the function $\secf(n)\cdot\adv_{\dev,\bbdev}^{\strongdetectplain}(\user)$ is negligible in $n$ because $\bb$ is assumed strongly undetectable. Since we also assumed that $\cgame$ is secure, $\adv_{\cgame}^{\secgame}(\adve')$ is also negligible in $n$. Negligibility is invariant under addition implying that the left-hand side above is negligible in $n$. We conclude that $\adv_{\bb}^{\secgame}(\adve)$ is negligible in $n$ as well and that $\bb$ preserves security.
\end{proof}

By \propref{preservabilityRedundant}, we do not need to prove preservability when proving that a big brother is a strong subversion. It would be handy if we could get any of the other two properties in \defref{nicgSubversion} for free too. The examples below show that this is impossible without weakening the definition. The first example shows that there exists a big brother which is strongly undetectable but not recoverable while the second example provides an example of a big brother that is recoverable but not undetectable.

\begin{ex}
\exlab{recoverabilityImportant}
Assume $\listcgame$ is a secure non-interactive cryptographic game. Then we define $\listbb$ as $\bbdev \defeq \dev$ (on all inputs) i.e. $\bbdev$ does not utilize $\bbpk$. Clearly it is impossible to distinguish between $\dev$ and $\bbdev$ because they return the exact same output generated in the exact same way. But it is also impossible to construct a recovery function whose advantage is non-negligible because the existence of such an algorithm would imply that $\cgame$ is not secure: $\bbrec$ can be used as a regular adversary (because $\bbdev$ does not use $\bbpk$) for $\cgame$ and win the security game $\secgame_{\cgame}^{\adve}(n)$ with non-negligible probability.
\end{ex}

\begin{ex}
\exlab{undetectabilityImportant}
Assume $\listcgame$ is a secure non-interactive cryptographic game. Then we define $\bbdev$ as $\dev$ except that we define the output $(\ptrans^{\bb}, \strans^{\bb})$ of $\bbdev$ as $\ptrans^{\bb} = \ptrans \vert\vert \strans$ ($\vert\vert$ denotes concatenation of two bit strings) and $\strans^{\bb} = \bot$, where $(\ptrans,\strans)$ was the original output defined by $\dev$. Obviously it is easy for a recovery algorithm to win the recovery game given $\ptrans^{\bb}$ because $\bbrec$ has access to all knowledge. On the other hand, it is trivial to distinguish between $\dev$ and $\bbdev$. 
\end{ex}

\exref{undetectabilityImportant} does not exactly follow the functional requirements meaning that by simply parsing the output from $\dev$ it is possible for a distinguisher to distinguish between $\dev$ and $\bbdev$. The construction in \figref{example1} provides another example that satisfy functional requirements, and is recoverable but not undetectable (although it is a bit artificial). In the description, we have omitted the predicate function, base probability and base factor since they are not important. 

\begin{boxfigTwo}{Example of a big brother that is recoverable but not undetectable.}{example1}
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
 	 \item[\underline{$\param(1^n)$}] ~ 
  	
		$(\cgroup,\order,\generator)\leftarrow\groupgen(1^n)$\\
		$\params \defeq (\cgroup,\order,\generator)$\\
		\Ret $\params$ 	
		
 	\item[\underline{$\dev(1^n,\params)$}] ~
 	
 		Parse: $\params = (\cgroup,\order,\generator)$\\
 		$x\leftarrow_R\Zq$ \\
 		$x'\leftarrow_R\Zq$ \\
 		$y\defeq g^x$ \\
 		$\tau_p \defeq (\cgroup,\order,\generator,y,x')$ \\
 		$\tau_s \defeq (\cgroup,\order,\generator,x)$ \\
 		\Ret $(\tau_p,\tau_s)$
 		\smallskip
  	\end{description}
\end{minipage}
    & 
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
  	 \item[\underline{$\param(1^n)$}] ~ 
  	
		$(\cgroup,\order,\generator)\leftarrow\groupgen(1^n)$\\
		$\params \defeq (\cgroup,\order,\generator)$\\
		\Ret $\params$ 	
		
 	\item[\underline{$\bbdev(1^n,\params,\bbpk)$}] ~
 	
 		Parse: $\params = (\cgroup,\order,\generator)$\\
 		$x\leftarrow_R\Zq$ \\
 		$x'\leftarrow_R\Zq$ \\
 		$y\defeq g^x$ \\
 		$\tau_p \defeq (\cgroup,\order,\generator,y,x)$ \\
 		$\tau_s \defeq (\cgroup,\order,\generator,x)$ \\
 		\Ret $(\tau_p,\tau_s)$
 		\smallskip
  	\end{description}
\end{minipage}
     \\ \hline 
	 A non-interactive cryptographic game $\cgame$ &
	  A big brother for the game $\cgame$
	 \\
\end{boxfigTwo}

\begin{comment}
We also provide an example where we show that a big brother can be a weak subversion but not strong subversion.\fxnote{Can I come up with an example?}

\begin{ex}
Hmm?
\end{ex}

Shitty example that weak undetectability is not enough

\begin{boxfigTwo}{Weak undetectability is not enough}{example2}
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
 	\item[\underline{$\dev(1^n,\params)$}] ~
 	
 		$x\leftarrow_R\Zq$ \\
 		$x'\leftarrow_R\Zq$ \\
 		$\tau_p \defeq (\cgroup,x')$ \\
 		$\tau_s \defeq (\cgroup,x)$ \\
 		\Ret $(\tau_p,\tau_s)$
  	\end{description}
\end{minipage}
    & 
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
		
 	\item[\underline{$\bbdev(1^n,\params,\bbpk)$}] ~

 		$x\leftarrow_R\Zq$ \\
 		$x'\leftarrow_R\Zq$ \\
 		$\tau_p \defeq (\cgroup,x)$ \\
 		$\tau_s \defeq (\cgroup,x)$ \\
 		\Ret $(\tau_p,\tau_s)$
  	\end{description}
\end{minipage}
     \\ \hline 
	 A non-interactive cryptographic game $\cgame$ &
	  A big brother for the game $\cgame$
	 \\
\end{boxfigTwo}
\end{comment}
 

\subsection{Interactive Subversion}
\seclab{interactiveSubversion}

Subversion of an interactive cryptographic game roughly follows the definition of a subversion of a non-interactive cryptographic game, but makes the games interactive.  

\begin{defn}
\deflab{icgSubversion}
	Given a secure interactive cryptographic game $\inlistcgame$. A big brother $\listbb$ for $\cgame$ is a weak/strong $(t,K)$-subversion of $\cgame$ if 
	\begin{enumerate}[1.]

		\item Big brother can recover information: define recovery advantage as
		\begin{align*} 
			\adv_{\bb}^{\inrecgame}(\bbrec)\defeq \secf(n)\cdot \left\vert \prob{\true\leftarrow \inrecgame_{\bb}^{\bbrec}(n)} - \basep(n)\right\vert,
		\end{align*}
		where the probability is over randomness used in game $\inrecgame_{\bb}^{\adve}(n)$, which is defined in \figref{interactiveRecSecGame}. $\bb$ recovers information if there exists $N\in\N$ such that
		\begin{align*}
			\adv_{\bb}^{\inrecgame}(\bbrec)>K
		\end{align*}
		for all $n>N$ and $\bbrec$ is a $\PPT$ party. 
		\item  Detection is impossible: for a $\PPT$ distinguisher $\dist$, we define 
		\begin{align*}
		\adv_{\dev,\bbdev}^{\innotationtypedetect}(\dist) \defeq 2\left\vert \prob{\true\leftarrow \intypedetect{\dev}{\bbdev}{\dist}}-\frac{1}{2}\right\vert 
		\end{align*}
		for $\type\in\{\weakly,\strongly\}$ and probability is taken over the randomness used in the game $\intypedetect{\dev}{\bbdev}{\dist}$ defined in \figref{interactivedetectgame}. A $\PPT$ distinguisher $\dist$ can not detect the subversion $\bb$ if there exists a negligible function $\negl$ such that
		\begin{align*}
			\adv_{\dev,\bbdev}^{\innotationtypedetect}(\dist)\leq \negl(n),
		\end{align*}
		where $\dist$ is allowed to make $t$ queries to oracle $\oracle$.
		\begin{boxfigTwo}{Distinguish game for weak/strong subversion.}{interactivedetectgame}
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
 	\item[\underline{\textbf{Game} $\inweakdetect{\dev}{\bbdev}{\eve}$}] ~
 	
 	 	Run $\param(1^n)$\\
 	 	Let $\params$ be the initial state \\
 		$(\bbpk,\bbsk)\leftarrow \bbgen(1^n,\params)$ \\
 		Send $\bbpk$ to $\eve$ \\
 		$\hat{b}\leftarrow \eve^{\oracle}$ \\
 		\Ret $\askequal{\hat{b}}{b}$

	\item[\underline{$\oracle$}] ~
	
		If $b=0$: $\{$ Run $\dev$ with $\eve$ \\
	    $(\ptrans,\strans)\leftarrow\return_{\dev}(\st_{\dev}) \}$ \\
		If $b=1$:$\{$ Run $\bbdev(\bbpk)$ with $\eve$ \\
		$(\ptrans,\strans)\leftarrow\return_{\bbdev}(\st_{\bbdev}) \}$ \\
		\Ret $\ptrans$
		\smallskip
  	\end{description}
\end{minipage}
    & 
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
 	\item[\underline{\textbf{Game} $\instrongdetect{\dev}{\bbdev}{\user}$}] ~
 	
 	 	Run $\param(1^n)$ \\
 	 	Let $\params$ be the initial state \\
 		$(\bbpk,\bbsk)\leftarrow \bbgen(1^n,\params)$ \\
 		Send $\bbpk$ to $\user$ \\
 		$\hat{b}\leftarrow \user^{\oracle}$ \\
 		\Ret $\askequal{\hat{b}}{b}$

	\item[\underline{$\oracle$}] ~
	
		If $b=0$: $\{$ Run $\dev$ with $\eve$ \\
	    $(\ptrans,\strans)\leftarrow\return_{\dev}(\st_{\dev}) \}$ \\
		If $b=1$:$\{$ Run $\bbdev(\bbpk)$ with $\eve$ \\
		$(\ptrans,\strans)\leftarrow\return_{\bbdev}(\st_{\bbdev}) \}$ \\
		\Ret $(\ptrans,\strans)$
		\smallskip
  	\end{description}
\end{minipage}
     \\ \hline 
	 $\eve$ is allowed to make $t$ queries to the oracle $\oracle$. &  $\user$ is allowed to make $t$ queries to the oracle $\oracle$ \\
	  Device and $\eve$ start with initial state $\params$ for each query. & Device and $\user$ start with initial state $\params$ for each query.
	 \\
\end{boxfigTwo}
		\item Preserve security: for every $\PPT$ adversary $\adve$ there exists a negligible function $\negl$ such that
		\begin{align*}
			\adv_{\bb}^{\insecgame}(\adve) \leq \negl(n).
		\end{align*}   
		The left-hand side is defined as
		\begin{align*}
			\adv_{\bb}^{\insecgame}(\adve) \defeq \secf(n)\cdot\left\vert \prob{\true\leftarrow\insecgame_{\bb}^{\adve}(n)} - \basep(n)\right\vert
		\end{align*}
		where the probability is over the randomness used in the game $\insecgame_{\bb}^{\adve}(n)$ defined in \figref{interactiveRecSecGame}.
		\begin{boxfigTwo}{Recovery (left) and preservability (right) game for big brother $\bb$.}{interactiveRecSecGame}
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
	\item[\underline{\textbf{Game} $\inrecgame_{\bb}^{\adve}(n)$}] ~
 	
 		Run $\param(1^n)$ \\
  		Let $\params$ be the initial state \\
 		$(\bbpk,\bbsk)\leftarrow \bbgen(1^n,\params)$ \\
 		Send $\bbpk$ to $\adve$ \\
 		Run $\bbdev(\bbpk)$ with $\adve$ \\
 		$(\ptrans,\strans)\leftarrow \return_{\bbdev}(\st_{\bbdev})$ \\	
 		$\delta\leftarrow \return_{\adve}(\st_{\adve},\bbsk)$ \\
 		$\bool \leftarrow \pred(\ptrans,\strans,\delta)$ \\
		\Ret $\bool$
		\smallskip
  	\end{description}
  	
\end{minipage}
    & 
\begin{minipage}{0.45\textwidth}
 	%\vspace{1ex}
    \smallskip
	\begin{description}
	\item[\underline{\textbf{Game} $\insecgame_{\bb}^{\adve}(n)$}] ~
 	
 		Run $\param(1^n)$ \\
 		Let $\params$ be the initial state \\
 		$(\bbpk,\bbsk)\leftarrow \bbgen(1^n,\params)$ \\
 		Send $\bbpk$ to $\adve$ \\
 		Run $\bbdev(\bbpk)$ with $\adve$ \\
 		$(\ptrans,\strans)\leftarrow \return_{\bbdev}(\st_{\bbdev})$ \\	
 		$\delta\leftarrow \return_{\adve}(\st_{\adve})$ \\
 		$\bool \leftarrow \pred(\ptrans,\strans,\delta)$ \\
 		\Ret $\bool$ 
		\smallskip
  	\end{description}
\end{minipage}
\\ 
\end{boxfigTwo}
	\end{enumerate}
$t$ is a polynomial in $n$ and $K\in(0,1]$. If (1) is true for arbitrary $t>0$ we call $\bb$ a weak/strong $K$-subversion of $\cgame$ and we call $\bb$ a weak/strong subversion of $\cgame$ if there exist some constant $K$ such that $\bb$ is a weak/strong $K$-subversion. If properties 1, 2 and 3 are satisfied we call $\bb$ \emph{recoverable}, \emph{undetectable} and \emph{security preserving}. Property 1, 2 and 3 above are referred to as \emph{recoverability}, \emph{undetectability} and \emph{preservability}, respectively.
\end{defn}

We give some comments on each game below:

\noindent\textbf{Recovery game:} The recovery game first runs the setup algorithm $\param$ and distributes the result to both $\adve$ and $\bbdev$. Thereafter, the big brother keys $(\bbpk,\bbsk)$ are generated and $\bbpk$ is given to $\adve$. Afterwards $\adve$ and $\bbdev$ starts their interaction. In the end $\adve$ must output information $\delta$ that will make the predicate function return $\true$. As mentioned in \secref{interactiveBigBrother} $\adve$ can adaptively choose its messages to $\bbdev$, making it very powerful. 

\noindent\textbf{Detection game:} In the strong undetectability game, the user $\user$ or eavesdropper $\eve$ are first given the parameters $\params$ before starting the interaction with one of the two devices $\dev$ or $\bbdev$. $\user$ or $\eve$ can at most start $t$ interactions with a device and for each interaction, both the device and $\user$ (or $\eve$), must start from the initial state $\params$ (i.e. they reset). In addition, for each interaction user $\user$ both learns the public output from the device and the private input while eavesdropper $\eve$ learns only $\ptrans$.

\noindent\textbf{Security game:} As in the non-interactive case the only difference between $\insecgame_{\bb}^{\adve}(n)$ and $\inrecgame_{\bb}^{\adve}(n)$ is that in the latter $\adve$ is given the big brother secret key while in the former this is not the case. 

We now aim to prove the same propositions as in the non-interactive case. We begin by proving that a strong subversion implies a weak subversion. 

\begin{prop}
\proplab{interactivestrongImplyWeak}
Let $\inlistcgame$ be an interactive cryptographic game and assume $\listbb$ is a strong $(t,K)$-subversion of $\cgame$. Then $\bb$ is also a weak $(t,K)$-subversion of $\cgame$. 
\end{prop}

The proof is a little different from  \propref{strongImplyWeak} because the distinguisher can now interact with each device and choose its own messages. This is fixed by constructing a user that acts like a proxy between a weak distinguisher and the device. 

\begin{proof}
Property (1) and (3) of \defref{icgSubversion} are clearly satisfied. Let $\eve$ be a $\PPT$ eavesdropper and consider Game $\inweakdetect{\dev}{\bbdev}{\eve}$. We will construct a user $\user$ that attacks the strong detection game using $\eve$ as a subroutine. We prove 
\begin{align}
\label{eq:1}
	\adv_{\dev,\bbdev}^{\inweakdetectplain}(\eve) = \adv_{\dev,\bbdev}^{\instrongdetectplain}(\user).
\end{align}
We give the details of $\user$ below: $\oracle$ is the device oracle in the game $\instrongdetect{\dev}{\bbdev}{\user}$. 

\begin{comment}
%\vspace*{-.3cm}
\begin{Algorithm}[]{7cm}
\captionUser
\caption{$\user$}
\label{alg:interactiveWeakStrong}
\begin{algorithmic}[1]
\Require $(\params,\bbpk)$ 
\State Initialise list $L_{\ptrans}$
\State Make $t$ queries to $\oracle$
\State Let $L_{\ptrans}$ contain the public transcripts from the queries to $\oracle$
\State Give $\params$ and $\bbpk$ to $\eve$
\State $\hat{b}\leftarrow\eve^{\oracle_{\user}}$
\State \Ret $\hat{b}$
\Statex\hrulefill
\end{algorithmic}
\begin{algorithmic}[1]
\Statex \underline{Device oracle: \textbf{$\oracle_{\user}$} $i$'th query}
\Statex
\State Interact using public transcript $L_{\ptrans}[i]$
\end{algorithmic}
\end{Algorithm}
\end{comment}

%\vspace*{-.3cm}
\begin{Algorithm}[]{7cm}
\captionUser
\caption{$\user$}
\label{alg:interactiveWeakStrong}
\begin{algorithmic}[1]
\Require $(\bbpk,\params)$ 
\State Give $(\bbpk,\params)$ to $\eve$
\State $\hat{b}\leftarrow\eve^{\oracle_{\eve}}$
\State \Ret $\hat{b}$
\Statex\hrulefill
\end{algorithmic}
\begin{algorithmic}[1]
\Statex \underline{Device oracle: \textbf{$\oracle_{\eve}$} $i$'th query}
\Statex
\State Query the oracle $\oracle$ that starts an interaction with device $D$, which is either device $\dev$ or device $\bbdev$, and at the same time $\user$ starts an interaction with $\eve$
\State $\user$ acts as a proxy between the two interactions: messages received from $\eve$ are send to $D$, and messages received from $D$ are send to $\eve$
\State When $\user$ in the end receives the public and secret transcripts from the interaction with $D$, send the public transcript to $\eve$
\end{algorithmic}
\end{Algorithm}

It is obvious that $\user$ is a $\PPT$ party because $\eve$ is. Now consider the answers $\eve$ receives in its interaction with $\user$. These answers are equal (and therefore distributed identically) to the answers $\eve$ would receive in the game $\inweakdetect{\dev}{\bbdev}{\eve}$. Since $\user$ outputs $\hat{b} = b$ if and only if $\eve$ outputs $\hat{b} = b$ we have
\begin{align*}
\adv_{\dev,\bbdev}^{\inweakdetectplain}(\eve) &= \secf(n)\left\vert \prob{\true\leftarrow \inweakdetect{\dev}{\bbdev}{\eve}}-\basep(n)\right\vert \\
	& = \secf(n)\left\vert \prob{\true\leftarrow \instrongdetect{\dev}{\bbdev}{\user}}-\basep(n)\right\vert \\
	& = \adv_{\dev,\bbdev}^{\instrongdetectplain}(\user) \leq \negl(n)
\end{align*}
for some negligible function $\negl$. Hence, \ref{eq:1} follows directly.
\end{proof}

Next we prove an interactive equivalent to \propref{preservabilityRedundant}. The proof is very similar to the proof of the proposition in the non-interactive case except that $\user$ must now act as a proxy.

\begin{prop}
\proplab{interactiveRedundant}
Let $\inlistcgame$ be an interactive cryptographic game and $\listbb$ a big brother for $\cgame$. If $\cgame$ is secure and $\bb$ is strongly undetectable, then $\bb$ also preserves security i.e. for all $\PPT$ adversaries $\adve$ there exists a negligible function $\negl$ such that
\begin{align*}
	\adv_{\bb}^{\insecgame}(\adve) \leq \negl(n).
\end{align*}
\end{prop}

\begin{proof}
		Let $\adve$ be a $\PPT$ adversary and consider the game $\insecgame_{\bb}^{\adve}(n)$. We construct a $\PPT$ user $\user$, using $\adve$ as a subroutine, that tries to distinguish between devices $\dev$ and $\bbdev$ in the game $\instrongdetect{\dev}{\bbdev}{\user}$. A detailed description of $\user$ is given below: in the description we use $\oracle$ to refer to the device oracle in the game $\instrongdetect{\dev}{\bbdev}{\user}$.
	
%\vspace*{-.3cm}
\begin{Algorithm}[]{6cm}
\captionUser
\caption{$\user$}
\label{alg:interactiveRedundantUser}
\begin{algorithmic}[1]
\Require $(\bbpk,\params)$
\State Give $(\bbpk,\params)$ to $\adve$
\State Query $\oracle$ that starts an interaction between $\user$ and either $\dev$ or $\bbdev$, and $\user$ simultaneously starts an interaction with $\adve$
\State Let $\user$ act as a proxy 
\State $\delta \leftarrow \return_{\adve}(\st_{\adve})$
\State $\bool \leftarrow \pred(\ptrans,\strans,\delta)$
\If{$\bool = \true$}
\State \Ret $1$
\Else
\State \Ret $0$
\EndIf
\end{algorithmic}
\end{Algorithm} 

Conditioning on the value of $b$ we obtain
\begin{align}
\label{eq:2}
	\adv_{\dev,\bbdev}^{\instrongdetectplain}(\user) = \left\vert \condprob{\bool = \true}{b = 1} + \condprob{\bool = \false}{b = 0} -1 \right\vert.
\end{align}
We proceed by considering each case separately. $b = 1$ implies that the transcript returned by $\oracle$ is generated by interacting with $\bbdev$ (through $\user$) with parameters $\params$ and big brother public key $\bbpk$. That is, the messages to $\adve$, sent by $\user$, are distributed identically as in the game $\insecgame_{\bb}^{\adve}(n)$. Therefore, the event that $\bool = \true$, has the same probability as $\adve$ outputs a valid $\delta$ i.e.
\begin{align}
\label{eq:3}
	\condprob{\bool = \true}{b = 1} = \prob{\true \leftarrow \insecgame_{\bb}^{\adve}(n)}.
\end{align}
Second case is $b = 0$, which means that the answer from $\oracle$ is computed by interacting with $\dev$ (through $\user$) with parameters $\params$. The distribution of the input to $\adve$ is therefore identical to the distribution given to $\adve$ in the modified game $\pneg{\insecgame}_{\cgame}^{\adve}(n)$ defined in \figref{inSecGameMod}. Note that this is a modification of the security game for $\cgame$.

\begin{boxfigGame}{Modified security game for a non-interactive cryptographic game $\cgame$.}{inSecGameMod}
  \begin{description}
	\item[\underline{\textbf{Game} $\pneg{\insecgame}_{\cgame}^{\adve}(n)$}] ~
 	
 		Run $\param(1^n)$ \\
 		Let $\params$ be the initial state \\
 		$(\bbpk,\bbsk)\leftarrow\bbgen(1^n,\params)$ \\
 		Give $\bbpk$ to $\adve$ \\
		Run $\dev$ with $\adve$ \\
 		$\delta\leftarrow\return_{\adve}(\st_{\adve})$ \\
 		$(\ptrans,\strans)\leftarrow \return_{\dev}(\st_{\dev})$ \\
 		$\bool \leftarrow \pred(\ptrans,\strans,\delta)$ \\
 		\Ret $\bool$		
  \end{description}
\end{boxfigGame}

Thus we have the following identity
\begin{align*}
	\condprob{\bool = \false}{b = 0} = \prob{\false \leftarrow \pneg{\insecgame}_{\cgame}^{\adve}(n)}.
\end{align*}
Since $\params$ and $\ptrans$ are independent of $\bbpk$, we can define a $\PPT$ adversary $\adve'$ for the game $\insecgame_{\cgame}^{\adve'}(n)$ that uses $\adve$ as a subroutine, such that
\begin{align}
\label{eq:4}
	\prob{\false\leftarrow \insecgame_{\cgame}^{\adve'}(n)} = \prob{\false \leftarrow \pneg{\insecgame}_{\cgame}^{\adve}(n)}.
\end{align}
Using identities \ref{eq:2}, \ref{eq:3} and \ref{eq:4} we obtain
\begin{align*}
	\adv_{\dev,\bbdev}^{\strongdetectplain}(\user) & = \left\vert \prob{\true\leftarrow \insecgame_{\bb}^{\adve}(n)} + \prob{\false \leftarrow \insecgame_{\cgame}^{\adve'}(n)} - 1\right\vert \\
	& = \left\vert \prob{\true\leftarrow \insecgame_{\bb}^{\adve}(n)} - \prob{\true \leftarrow \insecgame_{\cgame}^{\adve'}(n)}\right\vert \\
	& \geq \left\vert \prob{ \true\leftarrow \insecgame_{\bb}^{\adve}(n)} - \basep(n)\right\vert  - \left\vert \prob{\true \leftarrow \insecgame_{\cgame}^{\adve'}(n)} - \basep(n) \right\vert.
\end{align*}
By multiplying $\secf(n)$ on both sides and rearrange things a bit we get
\begin{align*}
\secf(n)\cdot \left(\adv_{\dev,\bbdev}^{\instrongdetectplain}(\user) + \adv_{\cgame}^{\insecgame}(\adve')\right) \geq \adv_{\bb}^{\insecgame}(\adve).
\end{align*}
We conclude that $\adv_{\bb}^{\insecgame}(\adve)$ is negligible in $n$ and that $\bb$ preserves security.
\end{proof}

As in the non-interactive case the two first properties in \defref{icgSubversion} can not be left out without changing the power of the definition. 

\begin{ex}
The example from \exref{recoverabilityImportant} works here as well. 
\end{ex}

\begin{ex}
The examples from \exref{undetectabilityImportant} works here as well because one can imagine an interaction between a device and another party $\party$ where $\party$ does not send any messages.
\end{ex}

In general a non-interactive cryptographic game can be seen as a special case of an interactive cryptographic game. 

\begin{comment}
As in the non-interactive case we can give a separating example for weak and strong undetectability. 

\begin{ex}
Hmm?\fxnote{Need this}
\end{ex}
 \end{comment}
